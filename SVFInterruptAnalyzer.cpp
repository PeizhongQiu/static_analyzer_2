#include <fstream>
#ifdef SVF_AVAILABLE
#include "SVF-LLVM/LLVMUtil.h"
#include "SVF-LLVM/SVFIRBuilder.h"
#include "SVF-LLVM/LLVMModule.h"
#include "SVFIR/SVFIR.h"
#include "WPA/Andersen.h"
#include "Graphs/VFG.h"
#include "Util/Options.h"
#include "Util/ExtAPI.h"
#endif

//===- SVFInterruptAnalyzer.cpp - SVF‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞ÂàÜÊûêÂô®ÂÆûÁé∞ --------------===//

#include "SVFInterruptAnalyzer.h"
#include "llvm/Bitcode/BitcodeReader.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/JSON.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Constants.h"
#include <fstream>
#include <chrono>
#include <algorithm>

#ifdef SVF_AVAILABLE
#include "SVF-LLVM/LLVMUtil.h"
#include "SVF-LLVM/SVFIRBuilder.h"
#include "SVF-LLVM/LLVMModule.h"
#include "WPA/Andersen.h"
#include "Graphs/VFG.h"
#include "Util/Options.h"
#endif

using namespace llvm;

//===----------------------------------------------------------------------===//
// Ê®°ÂùóÂä†ËΩΩ
//===----------------------------------------------------------------------===//

bool SVFInterruptAnalyzer::loadBitcodeFiles(const std::vector<std::string>& files) {
    outs() << "üì¶ Loading bitcode files...\n";
    outs() << "Total files to process: " << files.size() << "\n";
    
    if (!context) {
        errs() << "‚ùå No LLVM context provided\n";
        return false;
    }
    
    modules.clear();
    loaded_bc_files.clear();
    
    size_t loaded = 0;
    size_t failed = 0;
    
    for (const auto& file : files) {
        outs() << "Loading: " << file << "\n";
        
        auto BufferOrErr = MemoryBuffer::getFile(file);
        if (std::error_code EC = BufferOrErr.getError()) {
            outs() << "  ‚ö†Ô∏è  Cannot read file: " << EC.message() << "\n";
            failed++;
            continue;
        }
        
        auto ModuleOrErr = parseBitcodeFile(BufferOrErr.get()->getMemBufferRef(), *context);
        if (!ModuleOrErr) {
            outs() << "  ‚ö†Ô∏è  Cannot parse bitcode: " << toString(ModuleOrErr.takeError()) << "\n";
            failed++;
            continue;
        }
        
        auto M = std::move(ModuleOrErr.get());
        M->setModuleIdentifier(file);
        
        outs() << "  ‚úÖ Loaded (" << M->size() << " functions)\n";
        
        modules.push_back(std::move(M));
        loaded_bc_files.push_back(file);
        loaded++;
    }
    
    outs() << "üìä Module loading summary:\n";
    outs() << "  ‚úÖ Successfully loaded: " << loaded << "\n";
    outs() << "  ‚ùå Failed to load: " << failed << "\n";
    
    if (loaded == 0) {
        errs() << "‚ùå No modules loaded successfully\n";
        return false;
    }
    
    return true;
}

//===----------------------------------------------------------------------===//
// SVFÂàùÂßãÂåñ
//===----------------------------------------------------------------------===//

bool SVFInterruptAnalyzer::initializeSVF() {
    outs() << "üöÄ Initializing SVF analysis framework...\n";
    
    if (loaded_bc_files.empty()) {
        errs() << "‚ùå No bitcode files loaded\n";
        return false;
    }
    
#ifdef SVF_AVAILABLE
    return initializeSVFCore();
#else
    errs() << "‚ùå SVF not available at compile time\n";
    return false;
#endif
}

#ifdef SVF_AVAILABLE
bool SVFInterruptAnalyzer::initializeSVFCore() {
    auto start_time = std::chrono::high_resolution_clock::now();
    
    outs() << "üèóÔ∏è  Building SVFIR (SVF Intermediate Representation)...\n";
    outs() << "Input files for SVF:\n";
    for (size_t i = 0; i < loaded_bc_files.size() && i < 10; ++i) {
        outs() << "  [" << (i+1) << "] " << loaded_bc_files[i] << "\n";
    }
    if (loaded_bc_files.size() > 10) {
        outs() << "  ... and " << (loaded_bc_files.size() - 10) << " more files\n";
    }
    
    // ‰ΩøÁî®ExtAPI::setExtBcPath()ËÆæÁΩÆextapi.bcË∑ØÂæÑ
    std::string extapi_path = "/home/qpz/lab/SVF/Release-build/lib/extapi.bc";
    outs() << "Setting extapi.bc path: " << extapi_path << "\n";
    
    // Âú®buildSVFModule‰πãÂâçË∞ÉÁî®setExtBcPath
    SVF::ExtAPI::setExtBcPath(extapi_path);
    
    // ‰ΩøÁî®Ê≠£Á°ÆÁöÑbuildSVFModule API
    SVF::LLVMModuleSet::getLLVMModuleSet()->buildSVFModule(loaded_bc_files);
    
    // 1. ÊûÑÂª∫SVFIR - Áõ¥Êé•‰ΩøÁî®SVFIRBuilder
    SVF::SVFIRBuilder builder;
    svfir = std::unique_ptr<SVF::SVFIR>(builder.build());
    
    if (!svfir) {
        errs() << "‚ùå Failed to build SVFIR\n";
        return false;
    }
    
    outs() << "‚úÖ SVFIR built successfully\n";
    outs() << "üìä SVFIR Statistics:\n";
    outs() << "  Total nodes: " << svfir->getTotalNodeNum() << "\n";
    outs() << "  Total edges: " << svfir->getTotalEdgeNum() << "\n";
    outs() << "  Value nodes: " << svfir->getValueNodeNum() << "\n";
    
    // ‰ΩøÁî®Ê≠£Á°ÆÁöÑAPIËé∑ÂèñÂØπË±°ËäÇÁÇπÊï∞Èáè
    // ÈÄöËøáLLVMModuleSetËé∑Âèñ
    SVF::LLVMModuleSet* moduleSet = SVF::LLVMModuleSet::getLLVMModuleSet();
    outs() << "  Object nodes: " << moduleSet->getObjNodeNum() << "\n";
    
    if (svfir->getTotalNodeNum() == 0) {
        errs() << "‚ö†Ô∏è  SVFIR has no nodes - this indicates a problem with module loading\n";
        return false;
    }
    
    // 2. ËøêË°åÊåáÈíàÂàÜÊûê
    if (!runPointerAnalysis()) {
        errs() << "‚ùå Pointer analysis failed\n";
        return false;
    }
    
    // 3. ÊûÑÂª∫VFGÔºàÂèØÈÄâÔºâ
    if (!buildVFG()) {
        outs() << "‚ö†Ô∏è  VFG construction failed, but continuing with basic analysis\n";
    }
    
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    
    outs() << "‚è±Ô∏è  SVF initialization completed in " << duration.count() << " ms\n";
    svf_initialized = true;
    return true;
}

bool SVFInterruptAnalyzer::runPointerAnalysis() {
    outs() << "üéØ Running Andersen pointer analysis...\n";
    
    pta = std::make_unique<SVF::AndersenWaveDiff>(svfir.get());
    pta->analyze();
    
    outs() << "‚úÖ Pointer analysis completed\n";
    outs() << "üìä Pointer Analysis Statistics:\n";
    outs() << "  Analysis completed successfully\n";
    
    return true;
}

bool SVFInterruptAnalyzer::buildVFG() {
    outs() << "üåê Building Value Flow Graph...\n";
    
    try {
        vfg = std::make_unique<SVF::VFG>(pta->getCallGraph());
        
        outs() << "‚úÖ VFG built successfully\n";
        outs() << "üìä VFG Statistics:\n";
        outs() << "  VF nodes: " << vfg->getTotalNodeNum() << "\n";
        outs() << "  VF edges: " << vfg->getTotalEdgeNum() << "\n";
        
        return true;
    } catch (const std::exception& e) {
        outs() << "‚ö†Ô∏è  VFG construction failed: " << e.what() << "\n";
        return false;
    }
}

const SVF::Function* SVFInterruptAnalyzer::findSVFFunction(const std::string& name) {
    if (!svfir) return nullptr;
    
    // ÁÆÄÂåñÂÆûÁé∞ÔºöÂú®Ëøô‰∏™ÁâàÊú¨ÁöÑSVF‰∏≠ÔºåÊàë‰ª¨ÂèØËÉΩ‰∏çÈúÄË¶ÅÁõ¥Êé•Ëé∑ÂèñSVF::Function
    // Âõ†‰∏∫Êàë‰ª¨‰∏ªË¶ÅÈÄöËøáLLVM FunctionÂíåSVFÁöÑNodeIDÊù•Â∑•‰Ωú
    return nullptr;
}
#endif

//===----------------------------------------------------------------------===//
// ÂáΩÊï∞Êü•Êâæ
//===----------------------------------------------------------------------===//

Function* SVFInterruptAnalyzer::findFunction(const std::string& name) {
    for (auto& M : modules) {
        for (auto& F : *M) {
            if (F.getName() == name) {
                return &F;
            }
        }
    }
    return nullptr;
}

//===----------------------------------------------------------------------===//
// ‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞ÂàÜÊûê
//===----------------------------------------------------------------------===//

std::vector<InterruptHandlerResult> SVFInterruptAnalyzer::analyzeInterruptHandlers(const std::vector<std::string>& handler_names) {
    std::vector<InterruptHandlerResult> results;
    
    if (!svf_initialized) {
        errs() << "‚ùå SVF not initialized\n";
        return results;
    }
    
    outs() << "üîç Analyzing " << handler_names.size() << " interrupt handlers...\n";
    outs() << std::string(60, '=') << "\n";
    
    for (const auto& name : handler_names) {
        outs() << "üéØ Analyzing handler: " << name << "\n";
        
        Function* handler = findFunction(name);
        if (!handler) {
            outs() << "  ‚ùå Function not found in loaded modules\n";
            
            // ÂàõÂª∫Á©∫ÁªìÊûúËÆ∞ÂΩï
            InterruptHandlerResult result;
            result.function_name = name;
            result.analysis_complete = false;
            results.push_back(result);
            continue;
        }
        
        outs() << "  ‚úÖ Function found in module: " << handler->getParent()->getName() << "\n";
        
        InterruptHandlerResult result = analyzeSingleHandler(handler);
        results.push_back(result);
        
        outs() << "  üìä Analysis summary:\n";
        outs() << "    Instructions: " << result.total_instructions << "\n";
        outs() << "    Basic blocks: " << result.total_basic_blocks << "\n";
        outs() << "    Function calls: " << result.function_calls << "\n";
        outs() << "    Indirect calls: " << result.indirect_calls << "\n";
        outs() << "    Indirect call targets: " << result.indirect_call_targets.size() << "\n";
        outs() << "    Confidence: " << result.confidence_score << "/100\n";
        outs() << std::string(40, '-') << "\n";
    }
    
    outs() << "‚úÖ All handlers analyzed\n";
    return results;
}

InterruptHandlerResult SVFInterruptAnalyzer::analyzeSingleHandler(Function* handler) {
    InterruptHandlerResult result;
    result.function_name = handler->getName().str();
    result.module_file = handler->getParent()->getName().str();
    
    // Ëé∑ÂèñÊ∫êÊñá‰ª∂‰ø°ÊÅØ
    if (auto* SP = handler->getSubprogram()) {
        result.source_file = SP->getFilename().str();
    }
    
    // Âü∫Á°ÄÁªüËÆ°
    result.total_basic_blocks = handler->size();
    
    for (auto& BB : *handler) {
        result.total_instructions += BB.size();
        
        for (auto& I : BB) {
            if (auto* CI = dyn_cast<CallInst>(&I)) {
                result.function_calls++;
                if (!CI->getCalledFunction()) {
                    result.indirect_calls++;
                }
                
                // ËÆ∞ÂΩïË¢´Ë∞ÉÁî®ÁöÑÂáΩÊï∞
                if (CI->getCalledFunction()) {
                    result.called_functions.push_back(CI->getCalledFunction()->getName().str());
                }
            }
            
            if (isa<LoadInst>(&I) || isa<StoreInst>(&I)) {
                result.memory_operations++;
            }
            
            // Ê£ÄÊü•ÂÖ®Â±ÄÂèòÈáèËÆøÈóÆ
            for (auto& Op : I.operands()) {
                if (auto* GV = dyn_cast<GlobalVariable>(Op)) {
                    std::string gv_name = GV->getName().str();
                    if (std::find(result.accessed_global_variables.begin(), 
                                 result.accessed_global_variables.end(), gv_name) == 
                        result.accessed_global_variables.end()) {
                        result.accessed_global_variables.push_back(gv_name);
                    }
                }
            }
        }
    }
    
    // SVFÂàÜÊûê
#ifdef SVF_AVAILABLE
    if (svf_initialized) {
        result.indirect_call_targets = analyzeIndirectCalls(handler);
        result.pointer_analysis = analyzePointers(handler);
    }
#endif
    
    // Ê£ÄÊµã‰∏≠Êñ≠Â§ÑÁêÜÁâπÂæÅ
    detectInterruptFeatures(handler, result);
    
    // ËÆ°ÁÆóÁΩÆ‰ø°Â∫¶
    result.confidence_score = calculateConfidence(result);
    result.analysis_complete = true;
    
    return result;
}

//===----------------------------------------------------------------------===//
// SVFÂàÜÊûêÊñπÊ≥ï - ‰ΩøÁî®Ê≠£Á°ÆÁöÑLLVMModuleSet API
//===----------------------------------------------------------------------===//

#ifdef SVF_AVAILABLE
std::vector<std::string> SVFInterruptAnalyzer::analyzeIndirectCalls(Function* handler) {
    std::vector<std::string> targets;
    
    if (!pta || !svfir) return targets;
    
    // Ëé∑ÂèñLLVMModuleSetÂÆû‰æãÊù•ËÆøÈóÆhasValueNodeÂíågetValueNode
    SVF::LLVMModuleSet* moduleSet = SVF::LLVMModuleSet::getLLVMModuleSet();
    
    // ‰ΩøÁî®Ê≠£Á°ÆÁöÑSVF API
    for (auto& BB : *handler) {
        for (auto& I : BB) {
            if (auto* CI = dyn_cast<CallInst>(&I)) {
                if (!CI->getCalledFunction()) {
                    // ËøôÊòØÈó¥Êé•Ë∞ÉÁî®Ôºå‰ΩøÁî®SVFÂàÜÊûê
                    Value* calledValue = CI->getCalledOperand();
                    
                    // ‰ΩøÁî®LLVMModuleSetÊ£ÄÊü•ÊòØÂê¶ÊúâÂØπÂ∫îÁöÑËäÇÁÇπ
                    if (moduleSet->hasValueNode(calledValue)) {
                        SVF::NodeID callNodeId = moduleSet->getValueNode(calledValue);
                        const SVF::PointsTo& pts = pta->getPts(callNodeId);
                        
                        // Ëé∑ÂèñÂèØËÉΩÁöÑË∞ÉÁî®ÁõÆÊ†á
                        for (auto ptd : pts) {
                            const SVF::PAGNode* targetNode = svfir->getGNode(ptd);
                            if (const SVF::FunValVar* funVar = SVF::SVFUtil::dyn_cast<SVF::FunValVar>(targetNode)) {
                                targets.push_back(funVar->getFunction()->getName());
                            }
                        }
                    } else {
                        // Â¶ÇÊûúSVF‰∏≠Ê≤°ÊúâÂØπÂ∫îËäÇÁÇπÔºå‰ΩøÁî®Âü∫Á°ÄÂêØÂèëÂºèÂàÜÊûê
                        if (auto* arg = dyn_cast<Argument>(calledValue)) {
                            targets.push_back("function_pointer_arg_" + std::to_string(arg->getArgNo()));
                        } else if (auto* gv = dyn_cast<GlobalVariable>(calledValue)) {
                            targets.push_back("global_func_ptr_" + gv->getName().str());
                        } else {
                            targets.push_back("unknown_indirect_call");
                        }
                    }
                }
            }
        }
    }
    
    return targets;
}

std::map<std::string, std::vector<std::string>> SVFInterruptAnalyzer::analyzePointers(Function* handler) {
    std::map<std::string, std::vector<std::string>> pointer_info;
    
    if (!pta || !svfir) return pointer_info;
    
    // Ëé∑ÂèñLLVMModuleSetÂÆû‰æã
    SVF::LLVMModuleSet* moduleSet = SVF::LLVMModuleSet::getLLVMModuleSet();
    
    // ÂàÜÊûêÂáΩÊï∞‰∏≠ÁöÑÊåáÈíà
    for (auto& BB : *handler) {
        for (auto& I : BB) {
            if (I.getType()->isPointerTy()) {
                // ‰ΩøÁî®LLVMModuleSetÊ£ÄÊü•ÊòØÂê¶ÊúâÂØπÂ∫îÁöÑËäÇÁÇπ
                if (moduleSet->hasValueNode(&I)) {
                    SVF::NodeID nodeId = moduleSet->getValueNode(&I);
                    const SVF::PointsTo& pts = pta->getPts(nodeId);
                    
                    std::vector<std::string> pointed_objects;
                    for (auto ptd : pts) {
                        const SVF::PAGNode* objNode = svfir->getGNode(ptd);
                        // ÁÆÄÂåñÂ§ÑÁêÜÔºå‰∏ç‰ΩøÁî®ÂèØËÉΩ‰∏çÂ≠òÂú®ÁöÑhasValue/getValueÊñπÊ≥ï
                        pointed_objects.push_back("obj_" + std::to_string(ptd));
                    }
                    
                    if (!pointed_objects.empty()) {
                        std::string ptr_name = getInstructionInfo(&I);
                        pointer_info[ptr_name] = pointed_objects;
                    }
                }
            }
        }
    }
    
    return pointer_info;
}
#else
std::vector<std::string> SVFInterruptAnalyzer::analyzeIndirectCalls(Function* handler) {
    return std::vector<std::string>();
}

std::map<std::string, std::vector<std::string>> SVFInterruptAnalyzer::analyzePointers(Function* handler) {
    return std::map<std::string, std::vector<std::string>>();
}
#endif

//===----------------------------------------------------------------------===//
// ÁâπÂæÅÊ£ÄÊµã
//===----------------------------------------------------------------------===//

void SVFInterruptAnalyzer::detectInterruptFeatures(Function* handler, InterruptHandlerResult& result) {
    // Ê£ÄÊµãËÆæÂ§áËÆøÈóÆÊ®°Âºè
    for (auto& BB : *handler) {
        for (auto& I : BB) {
            if (auto* CI = dyn_cast<CallInst>(&I)) {
                if (CI->getCalledFunction()) {
                    std::string func_name = CI->getCalledFunction()->getName().str();
                    
                    if (isDeviceRelatedFunction(func_name)) {
                        result.has_device_access = true;
                    }
                    
                    if (isInterruptRelatedFunction(func_name)) {
                        result.has_irq_operations = true;
                    }
                    
                    // Ê£ÄÊµãÂ∑•‰ΩúÈòüÂàóÊìç‰Ωú
                    if (func_name.find("queue_work") != std::string::npos ||
                        func_name.find("schedule_work") != std::string::npos) {
                        result.has_work_queue_ops = true;
                    }
                }
            }
            
            // Ê£ÄÊµãÂèÇÊï∞ËÆøÈóÆÊ®°ÂºèÔºà‰∏≠Êñ≠Â§ÑÁêÜÂáΩÊï∞ÁöÑÂÖ∏ÂûãÊ®°ÂºèÔºâ
            if (auto* LI = dyn_cast<LoadInst>(&I)) {
                Value* ptr = LI->getPointerOperand();
                if (auto* arg = dyn_cast<Argument>(ptr)) {
                    if (arg->getParent() == handler && arg->getArgNo() == 1) {
                        result.has_device_access = true;  // ÈÄöÂ∏∏Á¨¨‰∫å‰∏™ÂèÇÊï∞ÊòØËÆæÂ§áÊï∞ÊçÆ
                    }
                }
            }
        }
    }
}

//===----------------------------------------------------------------------===//
// ËæÖÂä©ÂáΩÊï∞
//===----------------------------------------------------------------------===//

bool SVFInterruptAnalyzer::isInterruptRelatedFunction(const std::string& name) {
    static const std::vector<std::string> keywords = {
        "irq", "interrupt", "disable", "enable", "mask", "unmask", 
        "ack", "eoi", "handler", "isr", "softirq"
    };
    
    std::string lower_name = name;
    std::transform(lower_name.begin(), lower_name.end(), lower_name.begin(), ::tolower);
    
    for (const auto& keyword : keywords) {
        if (lower_name.find(keyword) != std::string::npos) {
            return true;
        }
    }
    return false;
}

bool SVFInterruptAnalyzer::isDeviceRelatedFunction(const std::string& name) {
    static const std::vector<std::string> keywords = {
        "pci", "device", "dev", "read", "write", "reg", "mmio", 
        "ioread", "iowrite", "inb", "outb", "readl", "writel"
    };
    
    std::string lower_name = name;
    std::transform(lower_name.begin(), lower_name.end(), lower_name.begin(), ::tolower);
    
    for (const auto& keyword : keywords) {
        if (lower_name.find(keyword) != std::string::npos) {
            return true;
        }
    }
    return false;
}

std::string SVFInterruptAnalyzer::getInstructionInfo(const Instruction* inst) {
    std::string info = inst->getOpcodeName();
    if (inst->hasName()) {
        info += "_" + inst->getName().str();
    }
    return info;
}

double SVFInterruptAnalyzer::calculateConfidence(const InterruptHandlerResult& result) {
    double score = 50.0;  // Âü∫Á°ÄÂàÜÊï∞
    
    // Ê†πÊçÆÂàÜÊûêÂÆåÊï¥ÊÄßÂä†ÂàÜ
    if (result.analysis_complete) score += 10.0;
    if (!result.indirect_call_targets.empty()) score += 15.0;
    if (!result.pointer_analysis.empty()) score += 10.0;
    
    // Ê†πÊçÆ‰∏≠Êñ≠Â§ÑÁêÜÁâπÂæÅÂä†ÂàÜ
    if (result.has_irq_operations) score += 15.0;
    if (result.has_device_access) score += 10.0;
    if (result.has_work_queue_ops) score += 5.0;
    
    // Ê†πÊçÆÂáΩÊï∞Â§çÊùÇÂ∫¶Ë∞ÉÊï¥
    if (result.total_instructions > 0) {
        if (result.total_instructions > 100) score += 5.0;
        if (result.function_calls > 5) score += 5.0;
    }
    
    return std::min(score, 100.0);
}

//===----------------------------------------------------------------------===//
// ËæìÂá∫ÂíåÁªüËÆ°
//===----------------------------------------------------------------------===//

void SVFInterruptAnalyzer::outputResults(const std::vector<InterruptHandlerResult>& results, const std::string& output_file) {
    json::Object root;
    json::Array handlers;
    
    for (const auto& result : results) {
        json::Object handler;
        
        handler["function_name"] = result.function_name;
        handler["source_file"] = result.source_file;
        handler["module_file"] = result.module_file;
        handler["total_instructions"] = (int64_t)result.total_instructions;
        handler["total_basic_blocks"] = (int64_t)result.total_basic_blocks;
        handler["function_calls"] = (int64_t)result.function_calls;
        handler["indirect_calls"] = (int64_t)result.indirect_calls;
        handler["memory_operations"] = (int64_t)result.memory_operations;
        handler["has_device_access"] = result.has_device_access;
        handler["has_irq_operations"] = result.has_irq_operations;
        handler["has_work_queue_ops"] = result.has_work_queue_ops;
        handler["analysis_complete"] = result.analysis_complete;
        handler["confidence_score"] = result.confidence_score;
        
        // Èó¥Êé•Ë∞ÉÁî®ÁõÆÊ†á
        json::Array targets;
        for (const auto& target : result.indirect_call_targets) {
            targets.push_back(target);
        }
        handler["indirect_call_targets"] = std::move(targets);
        
        // Ë¢´Ë∞ÉÁî®ÂáΩÊï∞
        json::Array called_funcs;
        for (const auto& func : result.called_functions) {
            called_funcs.push_back(func);
        }
        handler["called_functions"] = std::move(called_funcs);
        
        // ÂÖ®Â±ÄÂèòÈáèËÆøÈóÆ
        json::Array globals;
        for (const auto& gv : result.accessed_global_variables) {
            globals.push_back(gv);
        }
        handler["accessed_global_variables"] = std::move(globals);
        
        // ÊåáÈíàÂàÜÊûê
        json::Object pointers;
        for (const auto& pair : result.pointer_analysis) {
            json::Array objects;
            for (const auto& obj : pair.second) {
                objects.push_back(obj);
            }
            pointers[pair.first] = std::move(objects);
        }
        handler["pointer_analysis"] = std::move(pointers);
        
        handlers.push_back(std::move(handler));
    }
    
    root["interrupt_handlers"] = std::move(handlers);
    root["total_handlers"] = (int64_t)results.size();
    root["analysis_timestamp"] = (int64_t)std::time(nullptr);
    root["analyzer_version"] = "SVF-1.0";
    
    // ÁªüËÆ°‰ø°ÊÅØ
    size_t successful = 0;
    double avg_confidence = 0.0;
    for (const auto& result : results) {
        if (result.analysis_complete) successful++;
        avg_confidence += result.confidence_score;
    }
    if (!results.empty()) avg_confidence /= results.size();
    
    json::Object stats;
    stats["successful_analyses"] = (int64_t)successful;
    stats["average_confidence"] = avg_confidence;
    stats["total_modules_loaded"] = (int64_t)modules.size();
    
    root["statistics"] = std::move(stats);
    
    // ÂÜôÂÖ•Êñá‰ª∂
    std::error_code EC;
    raw_fd_ostream OS(output_file, EC);
    if (EC) {
        errs() << "‚ùå Error writing to " << output_file << ": " << EC.message() << "\n";
        return;
    }
    
    OS << formatv("{0:2}", json::Value(std::move(root))) << "\n";
    outs() << "üìÑ Results written to: " << output_file << "\n";
}

void SVFInterruptAnalyzer::printStatistics() const {
    outs() << "\nüìà SVF Interrupt Analyzer Statistics\n";
    outs() << "====================================\n";
    outs() << "Loaded modules: " << modules.size() << "\n";
    outs() << "Loaded bitcode files: " << loaded_bc_files.size() << "\n";
    outs() << "SVF initialized: " << (svf_initialized ? "Yes" : "No") << "\n";
    
#ifdef SVF_AVAILABLE
    if (svf_initialized && svfir) {
        outs() << "\nSVFIR Statistics:\n";
        outs() << "  Total nodes: " << svfir->getTotalNodeNum() << "\n";
        outs() << "  Total edges: " << svfir->getTotalEdgeNum() << "\n";
        outs() << "  Value nodes: " << svfir->getValueNodeNum() << "\n";
        
        // ‰ΩøÁî®Ê≠£Á°ÆÁöÑAPIËé∑ÂèñÂØπË±°ËäÇÁÇπÊï∞Èáè
        SVF::LLVMModuleSet* moduleSet = SVF::LLVMModuleSet::getLLVMModuleSet();
        outs() << "  Object nodes: " << moduleSet->getObjNodeNum() << "\n";
    }
    
    if (pta) {
        outs() << "\nPointer Analysis Statistics:\n";
        outs() << "  Analysis completed successfully\n";
    }
    
    if (vfg) {
        outs() << "\nVFG Statistics:\n";
        outs() << "  VF nodes: " << vfg->getTotalNodeNum() << "\n";
        outs() << "  VF edges: " << vfg->getTotalEdgeNum() << "\n";
    }
#endif
}
